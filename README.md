# Использование
~~~
python3 main.py HEAD~1^2 "new comment"
~~~
Программа изменяет комментарий на ***"new comment"***
для коммита ***HEAD~1^2***
~~~
python3 main.py -l HEAD deadbeef master~^ -c repo/
~~~
Опция ***-с*** задаёт путь к папке репозитория.
Программа открывает Ваш редактор по умолчанию, содержащий
хеши коммитов и существующие комментарии. Отредактируйте
комментарии и сохраните файл. Изменения будут записаны.
~~~
python3 main.py -f file.txt
~~~
Принимает файл с изменениями в формате:
~~~~
HEAD comment 1
deadbeef comment 2
hotfix~ comment 3
...
1337 comment n-2
b16b00b5 comment n-1
master^~^ comment n
~~~~
# Принцип работы
Первым делом, сканируются все файлы объектов, 
загружаются файлы коммитов и тегов. Далее составляется ориентированный граф коммитов.
при каждом изменении изменяется не только 
тот коммит, у которого мы хотим изменить комментарий, но и все его предки, так-как они содержат
SHA-1 своих предков. Для эффективного изменения, выделим подграф, содержащий коммиты которые изменятся.
Транспонируем матрицу связности (что-бы получить направление ребер от предка к наследнику) и обойдём граф.
Изменятся все вершины графа, до которых можно дойти из изменяемой точки.
После этого необходимо сохранить файлы коммитов и тегов, а после обновим логи и ссылки.

* Для обработки относительного указания коммитов используется подобие стекового калькулятора (только на очередях).

* Быстродействие не зависит от объема репозитория, а только от количества неупакованных коммитов.

# Проблемы
* git с версии 2.21 позволяет использовать SHA-256 в качестве id хешей, но в данной тулзе на такой случай есть тольуо икона
* нехватка времени заставила пойти простейшим путём-просканировать папки и загрузить все коммиты. Можно было попробовать 
грузить только необходимые коммиты на основании логов, но это гораздо сложнее сделать рабочим на любом репозитории с кучей 
веток, да и rebase наверняка может подзапутать лог. 